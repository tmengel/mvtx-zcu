-- Generated by PERL program wishbone.pl. Do not edit this file.
--
-- For defines see wishbone.defines
--
-- Generated Wed Mar  9 13:03:40 2016
--
-- Wishbone masters:
--   wbm1
--   wbm2
--
-- Wishbone slaves:
--   wbs1
--     baseadr 0x000 - size 0x100
--   wbs2
--     baseadr 0x100 - size 0x100
--   wbs3
--     baseadr 0x200 - size 0x100
--   wbs4
--     baseadr 0x300 - size 0x100
-----------------------------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;

package intercon_package is

  type wbm1_wbm_i_type is record
    dat_i : std_logic_vector(15 downto 0);
    err_i : std_logic;
    ack_i : std_logic;
  end record;
  type wbm1_wbm_o_type is record
    dat_o : std_logic_vector(15 downto 0);
    we_o  : std_logic;
    sel_o : std_logic_vector(1 downto 0);
    adr_o : std_logic_vector(11 downto 0);
    cyc_o : std_logic;
    stb_o : std_logic;
  end record;

  type wbm2_wbm_i_type is record
    dat_i : std_logic_vector(15 downto 0);
    err_i : std_logic;
    ack_i : std_logic;
  end record;
  type wbm2_wbm_o_type is record
    dat_o : std_logic_vector(15 downto 0);
    we_o  : std_logic;
    sel_o : std_logic_vector(1 downto 0);
    adr_o : std_logic_vector(11 downto 0);
    cyc_o : std_logic;
    stb_o : std_logic;
  end record;

  type wbs1_wbs_i_type is record
    dat_i : std_logic_vector(15 downto 0);
    we_i  : std_logic;
    sel_i : std_logic_vector(1 downto 0);
    adr_i : std_logic_vector(7 downto 0);
    cyc_i : std_logic;
    stb_i : std_logic;
  end record;
  type wbs1_wbs_o_type is record
    dat_o : std_logic_vector(15 downto 0);
    err_o : std_logic;
    ack_o : std_logic;
  end record;
  type wbs2_wbs_i_type is record
    dat_i : std_logic_vector(15 downto 0);
    we_i  : std_logic;
    sel_i : std_logic_vector(1 downto 0);
    adr_i : std_logic_vector(7 downto 0);
    cyc_i : std_logic;
    stb_i : std_logic;
  end record;
  type wbs2_wbs_o_type is record
    dat_o : std_logic_vector(15 downto 0);
    err_o : std_logic;
    ack_o : std_logic;
  end record;
  type wbs3_wbs_i_type is record
    dat_i : std_logic_vector(15 downto 0);
    we_i  : std_logic;
    sel_i : std_logic_vector(1 downto 0);
    adr_i : std_logic_vector(7 downto 0);
    cyc_i : std_logic;
    stb_i : std_logic;
  end record;
  type wbs3_wbs_o_type is record
    dat_o : std_logic_vector(15 downto 0);
    err_o : std_logic;
    ack_o : std_logic;
  end record;
  type wbs4_wbs_i_type is record
    dat_i : std_logic_vector(15 downto 0);
    we_i  : std_logic;
    sel_i : std_logic_vector(1 downto 0);
    adr_i : std_logic_vector(7 downto 0);
    cyc_i : std_logic;
    stb_i : std_logic;
  end record;
  type wbs4_wbs_o_type is record
    dat_o : std_logic_vector(15 downto 0);
    err_o : std_logic;
    ack_o : std_logic;
  end record;

  function "and" (
    l : std_logic_vector;
    r : std_logic)
    return std_logic_vector;
end intercon_package;
package body intercon_package is

  function "and" (
    l : std_logic_vector;
    r : std_logic)
    return std_logic_vector is
    variable result : std_logic_vector(l'range);
  begin  -- "and"
    for i in l'range loop
      result(i) := l(i) and r;
    end loop;  -- i
    return result;
  end "and";
end intercon_package;

library IEEE;
use IEEE.std_logic_1164.all;

entity traffic_supervision is

  generic (
    priority     : integer := 1;
    tot_priority : integer := 2);

  port (
    bg            : in  std_logic;      -- bus grant
    ce            : in  std_logic;      -- clock enable
    traffic_limit : out std_logic;
    clk           : in  std_logic;
    reset         : in  std_logic);

end traffic_supervision;

architecture rtl of traffic_supervision is

  signal shreg : std_logic_vector(tot_priority-1 downto 0);
  signal cntr  : integer range 0 to tot_priority;

begin  -- rtl

  -- purpose: holds information of usage of latest cycles
  -- type   : sequential
  -- inputs : clk, reset, ce, bg
  -- outputs: shreg('left)
  sh_reg : process (clk)
  begin  -- process shreg
    if rising_edge(clk) then
      if ce = '1' then
        shreg <= shreg(tot_priority-2 downto 0) & bg;
      end if;
    end if;
  end process sh_reg;

  -- purpose: keeps track of used cycles
  -- type   : sequential
  -- inputs : clk, reset, shreg('left), bg, ce
  -- outputs: traffic_limit
  counter : process (clk, reset)
  begin  -- process counter
    if reset = '1' then                 -- asynchronous reset (active hi)
      cntr          <= 0;
      traffic_limit <= '0';
    elsif rising_edge(clk) then         -- rising clock edge
      if ce = '1' then
        if bg = '1' and shreg(tot_priority-1) /= '1' then
          cntr <= cntr + 1;
          if cntr = priority-1 then
            traffic_limit <= '1';
          end if;
        elsif bg = '0' and shreg(tot_priority-1) = '1' then
          cntr <= cntr - 1;
          if cntr = priority then
            traffic_limit <= '0';
          end if;
        end if;
      end if;
    end if;
  end process counter;

end rtl;

library IEEE;
use IEEE.std_logic_1164.all;
use work.intercon_package.all;

entity intercon is
  port (
    -- wishbone master port(s)
    -- wbm1
    wbm1_wbm_i : out wbm1_wbm_i_type;
    wbm1_wbm_o : in  wbm1_wbm_o_type;
    -- wbm2
    wbm2_wbm_i : out wbm2_wbm_i_type;
    wbm2_wbm_o : in  wbm2_wbm_o_type;
    -- wishbone slave port(s)
    -- wbs1
    wbs1_wbs_i : out wbs1_wbs_i_type;
    wbs1_wbs_o : in  wbs1_wbs_o_type;
    -- wbs2
    wbs2_wbs_i : out wbs2_wbs_i_type;
    wbs2_wbs_o : in  wbs2_wbs_o_type;
    -- wbs3
    wbs3_wbs_i : out wbs3_wbs_i_type;
    wbs3_wbs_o : in  wbs3_wbs_o_type;
    -- wbs4
    wbs4_wbs_i : out wbs4_wbs_i_type;
    wbs4_wbs_o : in  wbs4_wbs_o_type;
    -- clock and reset
    clk        : in  std_logic;
    reset      : in  std_logic);
end intercon;
architecture rtl of intercon is
  signal wbm1_dat_i : std_logic_vector(15 downto 0);
  signal wbm1_ack_i : std_logic;
  signal wbm1_err_i : std_logic;
  signal wbm1_dat_o : std_logic_vector(15 downto 0);
  signal wbm1_we_o  : std_logic;
  signal wbm1_sel_o : std_logic_vector(1 downto 0);
  signal wbm1_adr_o : std_logic_vector(11 downto 0);
  signal wbm1_cyc_o : std_logic;
  signal wbm1_stb_o : std_logic;
  signal wbm2_dat_i : std_logic_vector(15 downto 0);
  signal wbm2_ack_i : std_logic;
  signal wbm2_err_i : std_logic;
  signal wbm2_dat_o : std_logic_vector(15 downto 0);
  signal wbm2_we_o  : std_logic;
  signal wbm2_sel_o : std_logic_vector(1 downto 0);
  signal wbm2_adr_o : std_logic_vector(11 downto 0);
  signal wbm2_cyc_o : std_logic;
  signal wbm2_stb_o : std_logic;
  signal wbs1_dat_o : std_logic_vector(15 downto 0);
  signal wbs1_ack_o : std_logic;
  signal wbs1_err_o : std_logic;
  signal wbs1_dat_i : std_logic_vector(15 downto 0);
  signal wbs1_we_i  : std_logic;
  signal wbs1_sel_i : std_logic_vector(1 downto 0);
  signal wbs1_adr_i : std_logic_vector(7 downto 0);
  signal wbs1_cyc_i : std_logic;
  signal wbs1_stb_i : std_logic;
  signal wbs2_dat_o : std_logic_vector(15 downto 0);
  signal wbs2_ack_o : std_logic;
  signal wbs2_err_o : std_logic;
  signal wbs2_dat_i : std_logic_vector(15 downto 0);
  signal wbs2_we_i  : std_logic;
  signal wbs2_sel_i : std_logic_vector(1 downto 0);
  signal wbs2_adr_i : std_logic_vector(7 downto 0);
  signal wbs2_cyc_i : std_logic;
  signal wbs2_stb_i : std_logic;
  signal wbs3_dat_o : std_logic_vector(15 downto 0);
  signal wbs3_ack_o : std_logic;
  signal wbs3_err_o : std_logic;
  signal wbs3_dat_i : std_logic_vector(15 downto 0);
  signal wbs3_we_i  : std_logic;
  signal wbs3_sel_i : std_logic_vector(1 downto 0);
  signal wbs3_adr_i : std_logic_vector(7 downto 0);
  signal wbs3_cyc_i : std_logic;
  signal wbs3_stb_i : std_logic;
  signal wbs4_dat_o : std_logic_vector(15 downto 0);
  signal wbs4_ack_o : std_logic;
  signal wbs4_err_o : std_logic;
  signal wbs4_dat_i : std_logic_vector(15 downto 0);
  signal wbs4_we_i  : std_logic;
  signal wbs4_sel_i : std_logic_vector(1 downto 0);
  signal wbs4_adr_i : std_logic_vector(7 downto 0);
  signal wbs4_cyc_i : std_logic;
  signal wbs4_stb_i : std_logic;
  signal wbm1_bg    : std_logic;        -- bus grant
  signal wbm2_bg    : std_logic;        -- bus grant
  signal wbs1_ss    : std_logic;        -- slave select
  signal wbs2_ss    : std_logic;        -- slave select
  signal wbs3_ss    : std_logic;        -- slave select
  signal wbs4_ss    : std_logic;        -- slave select
begin  -- rtl
  arbiter_sharedbus : block
    signal wbm1_bg_1, wbm1_bg_2, wbm1_bg_q : std_logic;
    signal wbm2_bg_1, wbm2_bg_2, wbm2_bg_q : std_logic;
    signal wbm1_traffic_ctrl_limit         : std_logic;
    signal wbm2_traffic_ctrl_limit         : std_logic;
    signal ack, ce, idle                   : std_logic;
  begin  -- arbiter
    ack <= wbs1_ack_o or wbs2_ack_o or wbs3_ack_o or wbs4_ack_o;

    traffic_supervision_1 : entity work.traffic_supervision
      generic map(
        priority     => 1,
        tot_priority => 3)
      port map(
        bg            => wbm1_bg,
        ce            => ce,
        traffic_limit => wbm1_traffic_ctrl_limit,
        clk           => clk,
        reset         => reset);

    traffic_supervision_2 : entity work.traffic_supervision
      generic map(
        priority     => 2,
        tot_priority => 3)
      port map(
        bg            => wbm2_bg,
        ce            => ce,
        traffic_limit => wbm2_traffic_ctrl_limit,
        clk           => clk,
        reset         => reset);

    process(clk, reset)
    begin
      if reset = '1' then
        wbm1_bg_q <= '0';
      elsif rising_edge(clk) then
        if wbm1_bg_q = '0' then
          wbm1_bg_q <= wbm1_bg;
        elsif ack = '1' then
          wbm1_bg_q <= '0';
        end if;
      end if;
    end process;

    process(clk, reset)
    begin
      if reset = '1' then
        wbm2_bg_q <= '0';
      elsif rising_edge(clk) then
        if wbm2_bg_q = '0' then
          wbm2_bg_q <= wbm2_bg;
        elsif ack = '1' then
          wbm2_bg_q <= '0';
        end if;
      end if;
    end process;

    idle <= '1' when wbm1_bg_q = '0' and wbm2_bg_q = '0'
            else '0';
    wbm1_bg_1 <= '1' when idle = '1' and wbm1_cyc_o = '1' and wbm1_traffic_ctrl_limit = '0'
                 else '0';
    wbm2_bg_1 <= '1' when idle = '1' and wbm2_cyc_o = '1' and wbm2_traffic_ctrl_limit = '0' and (wbm1_bg_1 = '0')
                 else '0';
    wbm1_bg_2 <= '1' when idle = '1' and (wbm1_bg_1 = '0' and wbm2_bg_1 = '0') and wbm1_cyc_o = '1'
                 else '0';
    wbm2_bg_2 <= '1' when idle = '1' and (wbm1_bg_1 = '0' and wbm2_bg_1 = '0' and wbm1_bg_2 = '0') and wbm2_cyc_o = '1'
                 else '0';
    wbm1_bg <= wbm1_bg_q or wbm1_bg_1 or wbm1_bg_2;
    wbm2_bg <= wbm2_bg_q or wbm2_bg_1 or wbm2_bg_2;
    ce      <= wbm1_cyc_o or wbm2_cyc_o when idle = '1' else '0';

  end block arbiter_sharedbus;

  decoder : block
    signal adr : std_logic_vector(11 downto 0);
  begin
    adr     <= (wbm1_adr_o and wbm1_bg) or (wbm2_adr_o and wbm2_bg);
    wbs1_ss <= '1' when adr(11 downto 8) = "0000" else
               '0';
    wbs2_ss <= '1' when adr(11 downto 8) = "0001" else
               '0';
    wbs3_ss <= '1' when adr(11 downto 8) = "0010" else
               '0';
    wbs4_ss <= '1' when adr(11 downto 8) = "0011" else
               '0';
    wbs1_adr_i <= adr(7 downto 0);
    wbs2_adr_i <= adr(7 downto 0);
    wbs3_adr_i <= adr(7 downto 0);
    wbs4_adr_i <= adr(7 downto 0);
  end block decoder;

  mux : block
    signal cyc, stb, we, ack : std_logic;
    signal err               : std_logic;
    signal sel               : std_logic_vector(1 downto 0);
    signal dat_m2s, dat_s2m  : std_logic_vector(15 downto 0);
  begin
    cyc        <= (wbm1_cyc_o and wbm1_bg) or (wbm2_cyc_o and wbm2_bg);
    wbs1_cyc_i <= wbs1_ss and cyc;
    wbs2_cyc_i <= wbs2_ss and cyc;
    wbs3_cyc_i <= wbs3_ss and cyc;
    wbs4_cyc_i <= wbs4_ss and cyc;
    stb        <= (wbm1_stb_o and wbm1_bg) or (wbm2_stb_o and wbm2_bg);
    wbs1_stb_i <= stb;
    wbs2_stb_i <= stb;
    wbs3_stb_i <= stb;
    wbs4_stb_i <= stb;
    we         <= (wbm1_we_o and wbm1_bg) or (wbm2_we_o and wbm2_bg);
    wbs1_we_i  <= we;
    wbs2_we_i  <= we;
    wbs3_we_i  <= we;
    wbs4_we_i  <= we;
    ack        <= wbs1_ack_o or wbs2_ack_o or wbs3_ack_o or wbs4_ack_o;
    wbm1_ack_i <= ack and wbm1_bg;
    wbm2_ack_i <= ack and wbm2_bg;
    err        <= wbs1_err_o or wbs2_err_o or wbs3_err_o or wbs4_err_o;
    wbm1_err_i <= err;
    wbm2_err_i <= err;
    sel        <= (wbm1_sel_o and wbm1_bg) or (wbm2_sel_o and wbm2_bg);
    wbs1_sel_i <= sel;
    wbs2_sel_i <= sel;
    wbs3_sel_i <= sel;
    wbs4_sel_i <= sel;
    dat_m2s    <= (wbm1_dat_o and wbm1_bg) or (wbm2_dat_o and wbm2_bg);
    wbs1_dat_i <= dat_m2s;
    wbs2_dat_i <= dat_m2s;
    wbs3_dat_i <= dat_m2s;
    wbs4_dat_i <= dat_m2s;
    dat_s2m    <= (wbs1_dat_o and wbs1_ss) or (wbs2_dat_o and wbs2_ss) or (wbs3_dat_o and wbs3_ss) or (wbs4_dat_o and wbs4_ss);
    wbm1_dat_i <= dat_s2m;
    wbm2_dat_i <= dat_s2m;
  end block mux;

  wbm1_wbm_i.dat_i <= wbm1_dat_i;
  wbm1_wbm_i.ack_i <= wbm1_ack_i;
  wbm1_wbm_i.err_i <= wbm1_err_i;
  wbm1_dat_o       <= wbm1_wbm_o.dat_o;
  wbm1_we_o        <= wbm1_wbm_o.we_o;
  wbm1_sel_o       <= wbm1_wbm_o.sel_o;
  wbm1_adr_o       <= wbm1_wbm_o.adr_o;
  wbm1_cyc_o       <= wbm1_wbm_o.cyc_o;
  wbm1_stb_o       <= wbm1_wbm_o.stb_o;
  wbm2_wbm_i.dat_i <= wbm2_dat_i;
  wbm2_wbm_i.ack_i <= wbm2_ack_i;
  wbm2_wbm_i.err_i <= wbm2_err_i;
  wbm2_dat_o       <= wbm2_wbm_o.dat_o;
  wbm2_we_o        <= wbm2_wbm_o.we_o;
  wbm2_sel_o       <= wbm2_wbm_o.sel_o;
  wbm2_adr_o       <= wbm2_wbm_o.adr_o;
  wbm2_cyc_o       <= wbm2_wbm_o.cyc_o;
  wbm2_stb_o       <= wbm2_wbm_o.stb_o;
  wbs1_dat_o       <= wbs1_wbs_o.dat_o;
  wbs1_ack_o       <= wbs1_wbs_o.ack_o;
  wbs1_err_o       <= wbs1_wbs_o.err_o;
  wbs1_wbs_i.dat_i <= wbs1_dat_i;
  wbs1_wbs_i.we_i  <= wbs1_we_i;
  wbs1_wbs_i.sel_i <= wbs1_sel_i;
  wbs1_wbs_i.adr_i <= wbs1_adr_i;
  wbs1_wbs_i.cyc_i <= wbs1_cyc_i;
  wbs1_wbs_i.stb_i <= wbs1_stb_i;
  wbs2_dat_o       <= wbs2_wbs_o.dat_o;
  wbs2_ack_o       <= wbs2_wbs_o.ack_o;
  wbs2_err_o       <= wbs2_wbs_o.err_o;
  wbs2_wbs_i.dat_i <= wbs2_dat_i;
  wbs2_wbs_i.we_i  <= wbs2_we_i;
  wbs2_wbs_i.sel_i <= wbs2_sel_i;
  wbs2_wbs_i.adr_i <= wbs2_adr_i;
  wbs2_wbs_i.cyc_i <= wbs2_cyc_i;
  wbs2_wbs_i.stb_i <= wbs2_stb_i;
  wbs3_dat_o       <= wbs3_wbs_o.dat_o;
  wbs3_ack_o       <= wbs3_wbs_o.ack_o;
  wbs3_err_o       <= wbs3_wbs_o.err_o;
  wbs3_wbs_i.dat_i <= wbs3_dat_i;
  wbs3_wbs_i.we_i  <= wbs3_we_i;
  wbs3_wbs_i.sel_i <= wbs3_sel_i;
  wbs3_wbs_i.adr_i <= wbs3_adr_i;
  wbs3_wbs_i.cyc_i <= wbs3_cyc_i;
  wbs3_wbs_i.stb_i <= wbs3_stb_i;
  wbs4_dat_o       <= wbs4_wbs_o.dat_o;
  wbs4_ack_o       <= wbs4_wbs_o.ack_o;
  wbs4_err_o       <= wbs4_wbs_o.err_o;
  wbs4_wbs_i.dat_i <= wbs4_dat_i;
  wbs4_wbs_i.we_i  <= wbs4_we_i;
  wbs4_wbs_i.sel_i <= wbs4_sel_i;
  wbs4_wbs_i.adr_i <= wbs4_adr_i;
  wbs4_wbs_i.cyc_i <= wbs4_cyc_i;
  wbs4_wbs_i.stb_i <= wbs4_stb_i;
end rtl;
